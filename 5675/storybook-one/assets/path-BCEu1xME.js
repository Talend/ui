const M=Math.PI,x=2*M,p=1e-6,T=x-p;function q(n){this._+=n[0];for(let t=1,i=n.length;t<i;++t)this._+=arguments[t]+n[t]}function A(n){let t=Math.floor(n);if(!(t>=0))throw new Error(`invalid digits: ${n}`);if(t>15)return q;const i=10**t;return function(s){this._+=s[0];for(let h=1,a=s.length;h<a;++h)this._+=Math.round(arguments[h]*i)/i+s[h]}}class L{constructor(t){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=t==null?q:A(t)}moveTo(t,i){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(t,i){this._append`L${this._x1=+t},${this._y1=+i}`}quadraticCurveTo(t,i,s,h){this._append`Q${+t},${+i},${this._x1=+s},${this._y1=+h}`}bezierCurveTo(t,i,s,h,a,_){this._append`C${+t},${+i},${+s},${+h},${this._x1=+a},${this._y1=+_}`}arcTo(t,i,s,h,a){if(t=+t,i=+i,s=+s,h=+h,a=+a,a<0)throw new Error(`negative radius: ${a}`);let _=this._x1,r=this._y1,u=s-t,$=h-i,e=_-t,l=r-i,o=e*e+l*l;if(this._x1===null)this._append`M${this._x1=t},${this._y1=i}`;else if(o>p)if(!(Math.abs(l*u-$*e)>p)||!a)this._append`L${this._x1=t},${this._y1=i}`;else{let c=s-_,f=h-r,g=u*u+$*$,E=c*c+f*f,m=Math.sqrt(g),b=Math.sqrt(o),v=a*Math.tan((M-Math.acos((g+o-E)/(2*m*b)))/2),d=v/b,w=v/m;Math.abs(d-1)>p&&this._append`L${t+d*e},${i+d*l}`,this._append`A${a},${a},0,0,${+(l*c>e*f)},${this._x1=t+w*u},${this._y1=i+w*$}`}}arc(t,i,s,h,a,_){if(t=+t,i=+i,s=+s,_=!!_,s<0)throw new Error(`negative radius: ${s}`);let r=s*Math.cos(h),u=s*Math.sin(h),$=t+r,e=i+u,l=1^_,o=_?h-a:a-h;this._x1===null?this._append`M${$},${e}`:(Math.abs(this._x1-$)>p||Math.abs(this._y1-e)>p)&&this._append`L${$},${e}`,s&&(o<0&&(o=o%x+x),o>T?this._append`A${s},${s},0,1,${l},${t-r},${i-u}A${s},${s},0,1,${l},${this._x1=$},${this._y1=e}`:o>p&&this._append`A${s},${s},0,${+(o>=M)},${l},${this._x1=t+s*Math.cos(a)},${this._y1=i+s*Math.sin(a)}`)}rect(t,i,s,h){this._append`M${this._x0=this._x1=+t},${this._y0=this._y1=+i}h${s=+s}v${+h}h${-s}Z`}toString(){return this._}}function C(n){return function(){return n}}const I=Math.abs,R=Math.atan2,Z=Math.cos,j=Math.max,k=Math.min,z=Math.sin,Q=Math.sqrt,S=1e-12,y=Math.PI,P=y/2,B=2*y;function D(n){return n>1?0:n<-1?y:Math.acos(n)}function F(n){return n>=1?P:n<=-1?-P:Math.asin(n)}function G(n){let t=3;return n.digits=function(i){if(!arguments.length)return t;if(i==null)t=null;else{const s=Math.floor(i);if(!(s>=0))throw new RangeError(`invalid digits: ${i}`);t=s}return n},()=>new L(t)}export{C as a,Q as b,Z as c,I as d,S as e,R as f,F as g,P as h,j as i,D as j,k as m,y as p,z as s,B as t,G as w};
