{"remainingRequest":"/Users/jmfrancois/github/talend/ui/packages/containers/sandbox/node_modules/babel-loader/lib/index.js??ref--4-1!/Users/jmfrancois/github/talend/ui/packages/containers/src/ComponentForm/kit/createTriggers.js","dependencies":[{"path":"/Users/jmfrancois/github/talend/ui/packages/containers/src/ComponentForm/kit/createTriggers.js","mtime":1581350832840},{"path":"/Users/jmfrancois/github/talend/ui/packages/containers/sandbox/node_modules/cache-loader/dist/cjs.js","mtime":1581407659958},{"path":"/Users/jmfrancois/github/talend/ui/packages/containers/sandbox/node_modules/babel-loader/lib/index.js","mtime":1581407659368}],"contextDependencies":[],"result":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n *  Copyright (C) 2006-2018 Talend Inc. - www.talend.com\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/* eslint-disable no-param-reassign */\nimport isEqual from 'lodash/isEqual';\nimport merge from 'lodash/merge';\nimport cmf from '@talend/react-cmf';\nimport { mergeCSRFToken } from '@talend/react-cmf/lib/middlewares/http/csrfHandling';\nimport flatten from './flatten';\nimport defaultRegistry from './defaultRegistry';\nvar DEFAULT_HEADERS = {\n  'Content-Type': 'application/json',\n  Accept: 'application/json'\n};\n\nfunction passthroughTrigger(_ref) {\n  var error = _ref.error,\n      trigger = _ref.trigger,\n      body = _ref.body;\n  // eslint-disable-next-line no-console\n  console.error(\"\".concat(JSON.stringify(trigger), \" doesnt exists or fails with error \").concat(error || '-'));\n  return body;\n}\n/**\n * array are describe without their index\n * use the schema to guess the path to use\n * to get the value in the properties\n * @param {string} specPath the path provided by the trigger\n * @param {Object} schema the schema of the current field\n * @return {string} path to get the value in properties\n */\n\n\nexport function getPathWithArrayIndex(specPath, schema) {\n  if (!schema) {\n    return specPath;\n  }\n\n  var contextualPathItems = schema.key;\n\n  if (!specPath || !contextualPathItems) {\n    return specPath;\n  }\n\n  var keyIndex = 0;\n  var schemaKey = schema.key;\n  return specPath.split('.').reduce(function (acc, current) {\n    if (acc) {\n      acc += '.';\n    }\n\n    if (current.endsWith('[]')) {\n      acc += \"\".concat(current.substring(0, current.length - 1)).concat(schemaKey[keyIndex + 1], \"]\");\n      keyIndex += 2;\n    } else {\n      acc += current;\n      keyIndex += 1;\n    }\n\n    return acc;\n  }, '');\n}\n/**\n * extract parameters from properties\n * @param {Array} parameters required\n * @param {Object} properties source of the data\n * @param {Object} schema of the current field the trigger is executed\n * @return {Object} payload of the trigger\n */\n\nexport function extractParameters(parameters, properties, schema) {\n  if (!parameters || !Array.isArray(parameters)) {\n    return {};\n  }\n\n  var flattenProps = flatten(properties, {\n    includeObjects: true\n  });\n  return parameters.reduce(function (acc, param) {\n    var path = getPathWithArrayIndex(param.path, schema);\n    var value = flattenProps[path];\n\n    if (_typeof(value) === 'object') {\n      Object.keys(value).filter(function (key) {\n        return _typeof(value[key]) !== 'object';\n      }).forEach(function (key) {\n        acc[\"\".concat(param.key).concat(key)] = value[key];\n      });\n    } else {\n      acc[param.key] = value;\n    }\n\n    return acc;\n  }, {});\n}\nexport function createCacheKey(trigger) {\n  if (trigger.type !== 'suggestions' || (trigger.parameters || []).length === 0) {\n    return undefined;\n  }\n\n  return \"\".concat(trigger.type, \":\").concat(trigger.family, \":\").concat(trigger.action, \":\").concat((trigger.parameters || []).map(function (it) {\n    return it.path;\n  }).join(':'));\n}\nexport function toJSON(resp) {\n  if (!resp.ok || resp.status >= 300) {\n    return resp.text().then(function (error) {\n      var json;\n\n      try {\n        json = JSON.parse(error);\n      } catch (e) {\n        json = {\n          error: error\n        };\n      }\n\n      throw json;\n    });\n  }\n\n  return resp.json();\n}\nexport function toQueryParam(obj) {\n  return Object.keys(obj).map(function (key) {\n    return \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(obj[key]));\n  }).join('&');\n} // customRegistry can be used to add extensions or custom trigger\n// (not portable accross integrations)\n\nexport default function createTriggers(_ref2) {\n  var url = _ref2.url,\n      customRegistry = _ref2.customRegistry,\n      _ref2$lang = _ref2.lang,\n      lang = _ref2$lang === void 0 ? 'en' : _ref2$lang,\n      headers = _ref2.headers,\n      fetchConfig = _ref2.fetchConfig,\n      _ref2$security = _ref2.security,\n      security = _ref2$security === void 0 ? {} : _ref2$security;\n\n  if (!url) {\n    throw new Error('url params is required to createTriggers');\n  }\n\n  var cache = {};\n  var actualHeaders = merge({}, DEFAULT_HEADERS, headers);\n  return function onDefaultTrigger(event, _ref3) {\n    var trigger = _ref3.trigger,\n        schema = _ref3.schema,\n        properties = _ref3.properties,\n        errors = _ref3.errors;\n\n    var services = _objectSpread({}, defaultRegistry, customRegistry);\n\n    var parameters = extractParameters(trigger.parameters, properties, schema);\n    var cacheKey = createCacheKey(trigger);\n\n    if (cacheKey) {\n      if (cache[cacheKey] && cache[cacheKey].result && isEqual(cache[cacheKey].parameters, parameters)) {\n        return Promise.resolve(cache[cacheKey].result);\n      } else if (cache[cacheKey]) {\n        delete cache[cacheKey];\n      }\n    }\n\n    function onSuccess(body) {\n      var result = (services[trigger.type] || passthroughTrigger)({\n        body: body,\n        errors: errors,\n        properties: properties,\n        schema: schema,\n        trigger: trigger\n      });\n\n      if (body.cacheable) {\n        cache[cacheKey] = {\n          parameters: parameters,\n          result: result\n        };\n      }\n\n      return result;\n    }\n\n    function onError(error) {\n      return services.error({\n        error: error,\n        errors: errors,\n        properties: properties,\n        schema: schema,\n        trigger: trigger\n      });\n    }\n\n    if (trigger.remote === false) {\n      var result = onSuccess({});\n\n      if (result && result.then) {\n        return result.catch(onError);\n      }\n\n      return new Promise(function (resolve) {\n        return resolve(result);\n      });\n    }\n\n    var config = cmf.sagas.http.getDefaultConfig() || {};\n    var httpSecurity = config.security || {};\n\n    if (security.CSRFTokenCookieKey || security.CSRFTokenHeaderKey) {\n      httpSecurity = security;\n    }\n\n    var fetchUrl = \"\".concat(url, \"?\").concat(toQueryParam({\n      lang: lang,\n      action: trigger.action,\n      family: trigger.family,\n      type: trigger.type\n    }));\n    return fetch(fetchUrl, mergeCSRFToken({\n      security: httpSecurity\n    })(_objectSpread({\n      method: 'POST',\n      headers: actualHeaders,\n      body: JSON.stringify(parameters),\n      credentials: 'include'\n    }, fetchConfig))).then(toJSON).then(onSuccess).catch(onError);\n  };\n}",{"version":3,"sources":["/Users/jmfrancois/github/talend/ui/packages/containers/src/ComponentForm/kit/createTriggers.js"],"names":["isEqual","merge","cmf","mergeCSRFToken","flatten","defaultRegistry","DEFAULT_HEADERS","Accept","passthroughTrigger","error","trigger","body","console","JSON","stringify","getPathWithArrayIndex","specPath","schema","contextualPathItems","key","keyIndex","schemaKey","split","reduce","acc","current","endsWith","substring","length","extractParameters","parameters","properties","Array","isArray","flattenProps","includeObjects","param","path","value","Object","keys","filter","forEach","createCacheKey","type","undefined","family","action","map","it","join","toJSON","resp","ok","status","text","then","json","parse","e","toQueryParam","obj","encodeURIComponent","createTriggers","url","customRegistry","lang","headers","fetchConfig","security","Error","cache","actualHeaders","onDefaultTrigger","event","errors","services","cacheKey","result","Promise","resolve","onSuccess","cacheable","onError","remote","catch","config","sagas","http","getDefaultConfig","httpSecurity","CSRFTokenCookieKey","CSRFTokenHeaderKey","fetchUrl","fetch","method","credentials"],"mappings":"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","sourcesContent":["/**\n *  Copyright (C) 2006-2018 Talend Inc. - www.talend.com\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n/* eslint-disable no-param-reassign */\n\nimport isEqual from 'lodash/isEqual';\nimport merge from 'lodash/merge';\nimport cmf from '@talend/react-cmf';\nimport { mergeCSRFToken } from '@talend/react-cmf/lib/middlewares/http/csrfHandling';\n\nimport flatten from './flatten';\nimport defaultRegistry from './defaultRegistry';\n\nconst DEFAULT_HEADERS = {\n\t'Content-Type': 'application/json',\n\tAccept: 'application/json',\n};\n\nfunction passthroughTrigger({ error, trigger, body }) {\n\t// eslint-disable-next-line no-console\n\tconsole.error(`${JSON.stringify(trigger)} doesnt exists or fails with error ${error || '-'}`);\n\treturn body;\n}\n\n/**\n * array are describe without their index\n * use the schema to guess the path to use\n * to get the value in the properties\n * @param {string} specPath the path provided by the trigger\n * @param {Object} schema the schema of the current field\n * @return {string} path to get the value in properties\n */\nexport function getPathWithArrayIndex(specPath, schema) {\n\tif (!schema) {\n\t\treturn specPath;\n\t}\n\tconst contextualPathItems = schema.key;\n\tif (!specPath || !contextualPathItems) {\n\t\treturn specPath;\n\t}\n\tlet keyIndex = 0;\n\tconst schemaKey = schema.key;\n\treturn specPath.split('.').reduce((acc, current) => {\n\t\tif (acc) {\n\t\t\tacc += '.';\n\t\t}\n\t\tif (current.endsWith('[]')) {\n\t\t\tacc += `${current.substring(0, current.length - 1)}${schemaKey[keyIndex + 1]}]`;\n\t\t\tkeyIndex += 2;\n\t\t} else {\n\t\t\tacc += current;\n\t\t\tkeyIndex += 1;\n\t\t}\n\t\treturn acc;\n\t}, '');\n}\n\n/**\n * extract parameters from properties\n * @param {Array} parameters required\n * @param {Object} properties source of the data\n * @param {Object} schema of the current field the trigger is executed\n * @return {Object} payload of the trigger\n */\nexport function extractParameters(parameters, properties, schema) {\n\tif (!parameters || !Array.isArray(parameters)) {\n\t\treturn {};\n\t}\n\tconst flattenProps = flatten(properties, { includeObjects: true });\n\treturn parameters.reduce((acc, param) => {\n\t\tconst path = getPathWithArrayIndex(param.path, schema);\n\t\tconst value = flattenProps[path];\n\t\tif (typeof value === 'object') {\n\t\t\tObject.keys(value)\n\t\t\t\t.filter(key => typeof value[key] !== 'object')\n\t\t\t\t.forEach(key => {\n\t\t\t\t\tacc[`${param.key}${key}`] = value[key];\n\t\t\t\t});\n\t\t} else {\n\t\t\tacc[param.key] = value;\n\t\t}\n\t\treturn acc;\n\t}, {});\n}\n\nexport function createCacheKey(trigger) {\n\tif (trigger.type !== 'suggestions' || (trigger.parameters || []).length === 0) {\n\t\treturn undefined;\n\t}\n\treturn `${trigger.type}:${trigger.family}:${trigger.action}:${(trigger.parameters || [])\n\t\t.map(it => it.path)\n\t\t.join(':')}`;\n}\n\nexport function toJSON(resp) {\n\tif (!resp.ok || resp.status >= 300) {\n\t\treturn resp.text().then(error => {\n\t\t\tlet json;\n\t\t\ttry {\n\t\t\t\tjson = JSON.parse(error);\n\t\t\t} catch (e) {\n\t\t\t\tjson = { error };\n\t\t\t}\n\t\t\tthrow json;\n\t\t});\n\t}\n\treturn resp.json();\n}\n\nexport function toQueryParam(obj) {\n\treturn Object.keys(obj)\n\t\t.map(key => `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`)\n\t\t.join('&');\n}\n\n// customRegistry can be used to add extensions or custom trigger\n// (not portable accross integrations)\nexport default function createTriggers({\n\turl,\n\tcustomRegistry,\n\tlang = 'en',\n\theaders,\n\tfetchConfig,\n\tsecurity = {},\n}) {\n\tif (!url) {\n\t\tthrow new Error('url params is required to createTriggers');\n\t}\n\tconst cache = {};\n\tconst actualHeaders = merge({}, DEFAULT_HEADERS, headers);\n\treturn function onDefaultTrigger(event, { trigger, schema, properties, errors }) {\n\t\tconst services = {\n\t\t\t...defaultRegistry,\n\t\t\t...customRegistry,\n\t\t};\n\t\tconst parameters = extractParameters(trigger.parameters, properties, schema);\n\t\tconst cacheKey = createCacheKey(trigger);\n\t\tif (cacheKey) {\n\t\t\tif (\n\t\t\t\tcache[cacheKey] &&\n\t\t\t\tcache[cacheKey].result &&\n\t\t\t\tisEqual(cache[cacheKey].parameters, parameters)\n\t\t\t) {\n\t\t\t\treturn Promise.resolve(cache[cacheKey].result);\n\t\t\t} else if (cache[cacheKey]) {\n\t\t\t\tdelete cache[cacheKey];\n\t\t\t}\n\t\t}\n\t\tfunction onSuccess(body) {\n\t\t\tconst result = (services[trigger.type] || passthroughTrigger)({\n\t\t\t\tbody,\n\t\t\t\terrors,\n\t\t\t\tproperties,\n\t\t\t\tschema,\n\t\t\t\ttrigger,\n\t\t\t});\n\t\t\tif (body.cacheable) {\n\t\t\t\tcache[cacheKey] = {\n\t\t\t\t\tparameters,\n\t\t\t\t\tresult,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tfunction onError(error) {\n\t\t\treturn services.error({\n\t\t\t\terror,\n\t\t\t\terrors,\n\t\t\t\tproperties,\n\t\t\t\tschema,\n\t\t\t\ttrigger,\n\t\t\t});\n\t\t}\n\t\tif (trigger.remote === false) {\n\t\t\tconst result = onSuccess({});\n\t\t\tif (result && result.then) {\n\t\t\t\treturn result.catch(onError);\n\t\t\t}\n\t\t\treturn new Promise(resolve => resolve(result));\n\t\t}\n\t\tconst config = cmf.sagas.http.getDefaultConfig() || {};\n\t\tlet httpSecurity = config.security || {};\n\t\tif (security.CSRFTokenCookieKey || security.CSRFTokenHeaderKey) {\n\t\t\thttpSecurity = security;\n\t\t}\n\t\tconst fetchUrl = `${url}?${toQueryParam({\n\t\t\tlang,\n\t\t\taction: trigger.action,\n\t\t\tfamily: trigger.family,\n\t\t\ttype: trigger.type,\n\t\t})}`;\n\t\treturn fetch(\n\t\t\tfetchUrl,\n\t\t\tmergeCSRFToken({ security: httpSecurity })({\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: actualHeaders,\n\t\t\t\tbody: JSON.stringify(parameters),\n\t\t\t\tcredentials: 'include',\n\t\t\t\t...fetchConfig,\n\t\t\t}),\n\t\t)\n\t\t\t.then(toJSON)\n\t\t\t.then(onSuccess)\n\t\t\t.catch(onError);\n\t};\n}\n"]}]}