import { Meta, Canvas, Story, Controls } from '@storybook/blocks';
import { FigmaImage, FigmaLink, Links } from '@talend/storybook-docs';
import * as Stories from './ButtonIcon.stories';
import { Status } from '../Status.block';

<Meta of={Stories} />
<Status id="buttonIcon" />

# ButtonIcon

This component should be used when icons are meant to be clicked on.

It handles the two largest usecases we have for clickable icons: actions and toggles.

- Always try use when an icon is meant to be clicked on.
- Always provide developers with copy for the tooltip.
- If the button holds the ON / OFF state of something, then use the Toggle variants.
- If the button is floating on top of something else, use the Floating variant.
- Only use size XS when absolutely unavoidable.
- Spacing between buttons should be at least 4px (XXS), 8px is best (XS).

## Zoning

<FigmaImage
	src="https://www.figma.com/file/qc8oUSyVJM67gSsbTShftt/%F0%9F%93%90-Zoning?node-id=1049%3A415"
	alt="zoning image for ButtonIcons"
/>

## Style

### Variations

<FigmaImage
	src="https://www.figma.com/file/KuJ1PlP77uyXlfOhdniqsZ/ButtonIcon?node-id=3232%3A34023"
	alt="variations image for ButtonIcon"
/>

<Canvas withSource="closed">
	<Story of={Stories.Variations} />
</Canvas>

#### Default

This is the go-to ButtonIcon for most generic actions.

<Canvas>
	<Story of={Stories.DefaultButtonIcon} />
</Canvas>

#### Toggle

If the button needs to hold an active / inactive state, then it is a Toggle.

Donâ€™t use Toggles in series, opt for badge dropdowns instead.

<Canvas>
	<Story of={Stories.DefaultButtonIconToggle} />
</Canvas>

#### Floating

This variant is only used when the button floats on top of content.

It could be it's sitting on top of a line connecting two nodes, or sticky on top of a draggable scene for instance.

<Canvas>
	<Story of={Stories.DefaultButtonIconFloating} />
</Canvas>

## States

ButtonIcons can display a "loading" state for asynchronous actions.

### Loading

Only use when necessary to avoid multiple clicks when the action is not instant.

<Canvas>
	<Story of={Stories.Loading} />
</Canvas>

### Skeleton

Skeletons are placeholders for UIs that are not yet ready but will feature a ButtonIcon.

The Loading state is for asynchronous tasks where the Button (and the button only) represents a pending state.

Skeleton needs are handled by the Skeleton component. Use `SkeletonButtonIcon` or the right `variant` prop on `Skeleton`.

<Canvas>
	<Story of={Stories.ButtonIconSkeletons} />
</Canvas>

[The Skeleton Documentation is over there!](/docs/feedback-skeleton--docs)

## Interaction

All buttons have interactive states for "hover", "active" and "disabled". A focus ring should also be displayed on keyboard navigation.

## Content

All ButtonIcons carry a tooltip on hover. The content of that tooltip should be short ("do something") and effective.

## Usage

You have access to three components with curated props for each.

### ButtonIcon

<Canvas>
	<Story of={Stories.Default} />
</Canvas>

<Controls of={Stories.Default} />

### ButtonIconToggle

<Canvas>
	<Story of={Stories.Toggle} />
</Canvas>

<Controls of={Stories.Toggle} />

### ButtonIconFloating

<Canvas>
	<Story of={Stories.Floating} />
</Canvas>

<Controls of={Stories.Floating} />

### Button props

Of course all buttons can also use natural `<button>` attributes (but not `classNames` nor `style`).

<Canvas>
	<Story of={Stories.NaturalButtonProps} />
</Canvas>

## Accessibility

In order to be semantically correct, `ButtonIconToggle`'s active state is dependent on the `aria-pressed` attribute being set to `true`.

This attribute is transparent to consumers of the component and providing the mandatory `isActive` prop will actually assign the correct `aria-pressed` value.
