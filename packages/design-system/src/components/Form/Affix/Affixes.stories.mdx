import { Canvas, Meta, Story } from '@storybook/addon-docs';
import { useForm } from 'react-hook-form';
import { FigmaImage } from '~docs';
import { InlineMessageInformation } from '../../InlineMessage';
import { ButtonPrimary } from '../../Button';
import Form from '../';
import * as Stories from './Affix.stories';

<Meta
	title="Components/Form/Form Fields/Prefix, Suffix"
	parameters={{
		status: { figma: 'ok', storybook: 'ok', react: 'ok', i18n: 'na' },
	}}
/>

# Affixes: `prefix` and `suffix` props

All the base inputs (`Form.Text`, `Form.Select`, `Form.Email`, `Form.Number` etc...) sport the ability to display affixes.

Fill in their `prefix` or `suffix` prop and the deed is done.

`Form.Textarea` and "on/off" inputs (`Radio`, `Checkbox` etc...) are not compatible with affixes.

## Zoning

<FigmaImage
	src="https://www.figma.com/file/qc8oUSyVJM67gSsbTShftt/%F0%9F%93%90-Zoning?node-id=249%3A129"
	alt="zoning image for field groups"
/>

## Style

### Variations

#### TL;DR

Affixes are either `prefix` or `suffix`. They are one of the following types:

<Canvas>
	<Story story={Stories.QuickStart} />
</Canvas>

Both `prefix` and `affix` accept the same 3 kinds of objects.

##### Select affixes

<FigmaImage
	src="https://www.figma.com/file/FaYIWpJeP6LwjWr78L8eAr/Forms?node-id=2008%3A1"
	alt="Select affixes"
/>

<Canvas withSource="closed">
	<Story story={Stories.AffixSelect} />
</Canvas>

##### Button affixes

<FigmaImage
	src="https://www.figma.com/file/FaYIWpJeP6LwjWr78L8eAr/Forms?node-id=2008%3A112"
	alt="Button affixes"
/>

<Canvas withSource="closed">
	<Story story={Stories.AffixButton} />
</Canvas>

##### Text affixes

<FigmaImage
	src="https://www.figma.com/file/FaYIWpJeP6LwjWr78L8eAr/Forms?node-id=2008%3A50"
	alt="Text affixes"
/>

<Canvas withSource="closed">
	<Story story={Stories.AffixText} />
</Canvas>

#### Datalist and multiple select

`Form.Datalist` and multiple selects also works with the same ruleset.

<Canvas>
	<Story story={Stories.DatalistAffix} />
</Canvas>

#### Mix and match

An input can mix multiple types of affixes indiscriminately.

<FigmaImage
	src="https://www.figma.com/file/FaYIWpJeP6LwjWr78L8eAr/Forms?node-id=2008%3A1010"
	alt="An input group demo"
/>

<Canvas>
	<Story story={Stories.Mix} />
</Canvas>

## States

Interactive affixes (button and select) have the states related to their type:

**`AffixSelect` and `AffixButton` can**

- Have the `hover` state
- Have the `active` state
- have the `disabled` state

They are not allowed the `read-only` state since a read-only `<select>` is actually a regular `read-only` text input, and a read-only button makes no sense.

## Content

Use lower case on prefix and suffix except if it's an interactive element.

## Interactions

## Usage

### Use with RHF

Here's an example using a `select` type affix with React Hooks Form

<Canvas>
	<Story name="react-hook-form">
		{() => {
			const { register, handleSubmit, watch } = useForm();
			const [formData, setFormData] = React.useState();
			return (
				<Form onSubmit={handleSubmit(setFormData)}>
					{formData && (
						<InlineMessageInformation
							title={'Form data'}
							description={JSON.stringify(formData, null, 2)}
							withBackground
						/>
					)}
					<Form.Text
						label="API Key"
						prefix={{
							...register('prefix'),
							type: 'select',
							label: 'Type',
							children: [
								<option value="Public">Public</option>,
								<option value="Private">Private</option>,
							],
							defaultValue: 'Public',
						}}
						suffix={{
							type: 'button',
							onClick: () => {},
							icon: 'talend-files-o',
							hideText: true,
							children: 'Do something',
						}}
						description="The input seems readonly and the value is not displayed while submitting the form"
						defaultValue={42}
						{...register('apiKey')}
					/>
					<Form.Buttons>
						<ButtonPrimary type="submit" onClick={() => {}}>
							Submit
						</ButtonPrimary>
					</Form.Buttons>
				</Form>
			);
		}}
	</Story>
</Canvas>

## Accessibility

- Text is mandatory, even when hidden as it is parsed by screen-readers.
